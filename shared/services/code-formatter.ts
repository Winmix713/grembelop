import { GeneratedComponent } from '../types/figma';
import { CodeGenerationOptions } from '../types/generator';

export class CodeFormatter {
  private options: CodeGenerationOptions;

  constructor(options: CodeGenerationOptions) {
    this.options = options;
  }

  formatReactComponent(component: GeneratedComponent): string {
    try {
      let formatted = component.jsx;

      if (this.options.includeComments) {
        formatted = this.addComments(formatted, component);
      }

      formatted = this.formatIndentation(formatted);
      formatted = this.formatImports(formatted);
      
      return formatted;
    } catch (error) {
      console.warn(`Failed to format React component ${component.name}:`, error);
      return component.jsx;
    }
  }

  formatVueComponent(component: GeneratedComponent): string {
    try {
      if (!component.vue) {
        return this.generateVueFromReact(component);
      }

      let formatted = component.vue;

      if (this.options.includeComments) {
        formatted = this.addVueComments(formatted, component);
      }

      formatted = this.formatIndentation(formatted);
      
      return formatted;
    } catch (error) {
      console.warn(`Failed to format Vue component ${component.name}:`, error);
      return component.vue || '';
    }
  }

  formatHTMLComponent(component: GeneratedComponent): string {
    try {
      if (!component.html) {
        return this.generateHTMLFromReact(component);
      }

      let formatted = component.html;

      if (this.options.includeComments) {
        formatted = this.addHTMLComments(formatted, component);
      }

      formatted = this.formatIndentation(formatted);
      
      return formatted;
    } catch (error) {
      console.warn(`Failed to format HTML component ${component.name}:`, error);
      return component.html || '';
    }
  }

  formatCSS(css: string, componentName: string): string {
    try {
      let formatted = css;

      // Add component header comment
      if (this.options.includeComments) {
        formatted = `/* ${componentName} Component Styles */\n${formatted}`;
      }

      // Format CSS rules
      formatted = this.formatCSSRules(formatted);
      
      // Add spacing between rules
      formatted = formatted.replace(/}\s*\./g, '}\n\n.');
      formatted = formatted.replace(/}\s*@/g, '}\n\n@');

      return formatted;
    } catch (error) {
      console.warn(`Failed to format CSS for ${componentName}:`, error);
      return css;
    }
  }

  formatTypeScript(typescript: string, componentName: string): string {
    try {
      let formatted = typescript;

      if (this.options.includeComments) {
        formatted = `// ${componentName} Component Types\n${formatted}`;
      }

      formatted = this.formatIndentation(formatted);
      
      return formatted;
    } catch (error) {
      console.warn(`Failed to format TypeScript for ${componentName}:`, error);
      return typescript;
    }
  }

  generateTestFile(component: GeneratedComponent): string {
    if (!this.options.generateTests) return '';

    try {
      const testTemplate = this.getTestTemplate(component);
      return this.formatIndentation(testTemplate);
    } catch (error) {
      console.warn(`Failed to generate test file for ${component.name}:`, error);
      return '';
    }
  }

  private addComments(jsx: string, component: GeneratedComponent): string {
    const header = `/**
 * ${component.name} Component
 * 
 * Generated by AdvancedCodeGenerator
 * Complexity: ${component.metadata.complexity}
 * Estimated Accuracy: ${component.metadata.estimatedAccuracy}%
 * Node Count: ${component.metadata.nodeCount}
 * 
 * Accessibility Score: ${component.accessibility.score}/100
 * WCAG Compliance: ${component.accessibility.wcagCompliance}
 * 
 * ${component.metadata.warnings.length > 0 ? 
   `Warnings:\n * ${component.metadata.warnings.join('\n * ')}` : 
   'No warnings'}
 */\n\n`;

    return header + jsx;
  }

  private addVueComments(vue: string, component: GeneratedComponent): string {
    const header = `<!-- 
${component.name} Component

Generated by AdvancedCodeGenerator
Complexity: ${component.metadata.complexity}
Estimated Accuracy: ${component.metadata.estimatedAccuracy}%
Node Count: ${component.metadata.nodeCount}

Accessibility Score: ${component.accessibility.score}/100
WCAG Compliance: ${component.accessibility.wcagCompliance}
-->\n\n`;

    return header + vue;
  }

  private addHTMLComments(html: string, component: GeneratedComponent): string {
    const header = `<!-- 
${component.name} Component

Generated by AdvancedCodeGenerator
Complexity: ${component.metadata.complexity}
Estimated Accuracy: ${component.metadata.estimatedAccuracy}%
Node Count: ${component.metadata.nodeCount}

Accessibility Score: ${component.accessibility.score}/100
WCAG Compliance: ${component.accessibility.wcagCompliance}
-->\n\n`;

    return header + html;
  }

  private formatIndentation(code: string, indentSize: number = 2): string {
    const lines = code.split('\n');
    let indentLevel = 0;
    const indentChar = ' '.repeat(indentSize);

    return lines.map(line => {
      const trimmedLine = line.trim();
      
      if (!trimmedLine) return '';

      // Decrease indent for closing tags/brackets
      if (trimmedLine.startsWith('</') || 
          trimmedLine.startsWith('}') || 
          trimmedLine.startsWith(')') ||
          trimmedLine === '>;') {
        indentLevel = Math.max(0, indentLevel - 1);
      }

      const indentedLine = indentChar.repeat(indentLevel) + trimmedLine;

      // Increase indent for opening tags/brackets
      if (trimmedLine.includes('<') && !trimmedLine.includes('</') && !trimmedLine.endsWith('/>') ||
          trimmedLine.endsWith('{') ||
          trimmedLine.endsWith('(')) {
        indentLevel++;
      }

      return indentedLine;
    }).join('\n');
  }

  private formatImports(jsx: string): string {
    const lines = jsx.split('\n');
    const imports: string[] = [];
    const rest: string[] = [];
    let inImports = true;

    lines.forEach(line => {
      if (line.trim().startsWith('import ') || line.trim().startsWith('// import')) {
        imports.push(line);
      } else if (line.trim() === '') {
        if (inImports) {
          imports.push(line);
        } else {
          rest.push(line);
        }
      } else {
        inImports = false;
        rest.push(line);
      }
    });

    // Sort imports
    const sortedImports = imports
      .filter(line => line.trim())
      .sort((a, b) => {
        // React imports first
        if (a.includes('react') && !b.includes('react')) return -1;
        if (!a.includes('react') && b.includes('react')) return 1;
        
        // UI components next
        if (a.includes('@/') && !b.includes('@/')) return 1;
        if (!a.includes('@/') && b.includes('@/')) return -1;
        
        return a.localeCompare(b);
      });

    return [...sortedImports, '', ...rest.filter(line => line.trim() || rest.indexOf(line) === rest.length - 1)].join('\n');
  }

  private formatCSSRules(css: string): string {
    return css
      .replace(/\s*{\s*/g, ' {\n  ')
      .replace(/;\s*/g, ';\n  ')
      .replace(/\s*}\s*/g, '\n}\n')
      .replace(/\n\s*\n/g, '\n');
  }

  private generateVueFromReact(component: GeneratedComponent): string {
    // This is a simplified conversion from React to Vue
    // In a real implementation, this would be much more sophisticated
    const reactJSX = component.jsx;
    
    // Extract component name
    const nameMatch = reactJSX.match(/export const (\w+)/);
    const componentName = nameMatch ? nameMatch[1] : 'Component';

    // Extract props
    const propsMatch = reactJSX.match(/\{\s*([^}]+)\s*\}/);
    const props = propsMatch ? propsMatch[1].split(',').map(p => p.trim()) : [];

    // Convert JSX to Vue template (simplified)
    let template = reactJSX
      .replace(/className=/g, 'class=')
      .replace(/\{([^}]+)\}/g, '{{ $1 }}')
      .replace(/export const \w+[^{]+\{[^]*?return \(\s*/, '')
      .replace(/\s*\);\s*\};?\s*export default \w+;?$/, '');

    const vueComponent = `<template>
${template}
</template>

<script>
export default {
  name: '${componentName}',
  props: {${props.map(prop => `
    ${prop}: {
      type: String,
      default: ''
    }`).join(',')}
  }
}
</script>

<style scoped>
${component.css}
</style>`;

    return vueComponent;
  }

  private generateHTMLFromReact(component: GeneratedComponent): string {
    // This is a simplified conversion from React to HTML
    let html = component.jsx;
    
    // Remove React-specific code
    html = html.replace(/import[^;]+;/g, '');
    html = html.replace(/export[^{]+\{[^]*?return \(\s*/, '');
    html = html.replace(/\s*\);\s*\};?\s*export default[^;]+;?$/, '');
    
    // Convert JSX to HTML
    html = html.replace(/className=/g, 'class=');
    html = html.replace(/\{([^}]+)\}/g, '$1');
    html = html.replace(/\s*\/>/g, '>');
    
    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${component.name}</title>
    <style>
${component.css}
    </style>
</head>
<body>
${html}
</body>
</html>`;
  }

  private getTestTemplate(component: GeneratedComponent): string {
    return `import { render, screen } from '@testing-library/react';
import { ${component.name} } from './${component.name}';

describe('${component.name}', () => {
  it('should render without crashing', () => {
    render(<${component.name} />);
  });

  ${component.metadata.suggestedProps.filter(prop => prop.required).map(prop => `
  it('should render with ${prop.name} prop', () => {
    const test${prop.name.charAt(0).toUpperCase() + prop.name.slice(1)} = 'test value';
    render(<${component.name} ${prop.name}={test${prop.name.charAt(0).toUpperCase() + prop.name.slice(1)}} />);
    // Add your assertions here
  });`).join('')}

  ${component.accessibility.score < 80 ? `
  it('should meet accessibility standards', () => {
    // TODO: Add accessibility tests
    // Current accessibility score: ${component.accessibility.score}/100
    // Issues to address: ${component.accessibility.issues.map(issue => issue.message).join(', ')}
  });` : ''}
});`;
  }
}
